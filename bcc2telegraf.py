#!/usr/bin/python 

# Based on the https://github.com/iovisor/bcc/blob/tag_v0.10.0/src/python/bcc/table.py
# Modified by https://github.com/unPeter
# --------------------------------------------------------------------
# Copyright 2015 by PLUMgrid
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
# --------------------------------------------------------------------
# This integration sends ebpf-based bcc metrics (https://github.com/iovisor/bcc)  to telegraf daemon (https://github.com/influxdata/telegraf)
# 
# Thank you so much to all of you wonderful stackoverflow contributors!
#
# Original bcc/table.py v.0.10 just printed histograms to stdout.
# This extension instead creates a memory buffer full of text lines formatted to the requirements of telegraf line protocol 
#  and sends it by http to telegraf url .
#
# You may create some function which extends tag1 with some other tags, based on the histogram bucket struct key described in ebpf C program
# e.g. your_function returns "8.8.8.8,cloud=GCP" 
# pass this function to this API: send_log2_hist (... bucket_fn=your_function...)
# and telegraf line will contain "... tag1=8.8.8.8,cloud=GCP..."
#
# Usage: 
# 1.set TELEGRAF_URL environment variable to your telegraf service 
# 2.copy a python-based bcc program
# 3.edit it, adding an
#          import bcc2telegraf
#    and replace instances of 
#          dist.print_log2_hist(label...)
#    with 
#          dist.send_log2_hist(label...)
#    or with 
#          dist.send_log2_hist(label,bucket_fn=your_function...)
# 4. maybe create a systemctl-managed service out of that program

from __future__ import print_function
import ctypes as ct
import bcc 
import os
import sys
import time
import requests
from io import BytesIO as StringIO
import socket 

# sample telegraf line generated by this module:
# ebpf,metric=biolatency,host=abc.example.com,dc=east-1,tag1=dm-14,cloud=Nine,hi=1024 value=777 1645026564
telegraf_line_format = "%s,metric=%s,host=%s,dc=%s,tag1=%s,hi=%d value=%d %d"

localhost_fqdn = socket.getaddrinfo(socket.gethostname(), 0, 0, 0, 0, socket.AI_CANONNAME)[0][3]
grafana_namespace = 'ebpf'
this_module = os.path.basename(sys.argv[0])
this_datacenter=os.environ.get('LOCAL_DATACENTER', 'unset')
telegraf_url=os.environ.get('TELEGRAF_URL', 'http://127.0.0.1:8086/write')
telegraf_headers = {'Content-Type': 'text/plain; charset=utf-8','User-Agent': 'Mozilla 5.x'} 
log2_index_max=bcc.table.log2_index_max

def _send_log2_hist(output,current_time, vals, val_type, strip_leading_zero,bucket='all',cumulative_hist=None):
    log2_dist_max = 64
    idx_max = -1
    val_max = 0

    for i, v in enumerate(vals):
        if v > 0: idx_max = i
        if v > val_max: val_max = v

    # bcc/ebpf creates log2 histograms 
    # some tools may require cumulative histograms, where each bucket starts with 0
    cumulative = 0
    for i in range(1, idx_max + 1):
        low = (1 << i) >> 1
        high = (1 << i) - 1
        if low == high:
            low -= 1
        val = vals[i]
        if cumulative_hist:
            val = val + cumulative
        cumulative=val
        
        #  ignore strip_leading_zero - never send zero counts to telegraf
        if val:
                print(telegraf_line_format % (grafana_namespace, this_module, localhost_fqdn, this_datacenter, bucket, high, val, current_time), file=output)

def send_log2_hist(self, val_type="value", section_header="tag1",
            section_print_fn=None, bucket_fn=None, strip_leading_zero=None,
            bucket_sort_fn=None, filter_list=None, cumulative_hist=None):
        
        output = StringIO('')
        current_time = int(time.time())

        if isinstance(self.Key(), ct.Structure):
            tmp = {}
            f1 = self.Key._fields_[0][0]
            f2 = self.Key._fields_[1][0]

            # The above code assumes that self.Key._fields_[1][0] holds the
            # slot. But a padding member may have been inserted here, which
            # breaks the assumption and leads to chaos.
            # TODO: this is a quick fix. Fixing/working around in the BCC
            # internal library is the right thing to do.
            if f2 == '__pad_1' and len(self.Key._fields_) == 3:
                f2 = self.Key._fields_[2][0]

            for k, v in self.items():
                bucket = getattr(k, f1)
                if (filter_list and bucket in filter_list) or not filter_list:
                    if bucket_fn:
                        bucket = bucket_fn(bucket)
                    vals = tmp[bucket] = tmp.get(bucket, [0] * log2_index_max)
                    slot = getattr(k, f2)
                    vals[slot] = v.value
            #  debug
            #  else:
            #      print(bucket)

            buckets = list(tmp.keys())
           
            #  send to telegraf unsorted, ignore bucket_sort_fn

            for bucket in buckets:
                vals = tmp[bucket]
                _send_log2_hist(output, current_time, vals, val_type, strip_leading_zero, bucket, cumulative_hist)
        else:
            vals = [0] * log2_index_max
            for k, v in self.items():
                vals[k.value] = v.value
            _send_log2_hist(output, current_time, vals, val_type, strip_leading_zero, cumulative_hist)

        contents = output.getvalue()
        output.close()
        print(contents,end="")
        response = requests.post(telegraf_url,headers=telegraf_headers,data=contents)
        print(response)


bcc.table.TableBase.send_log2_hist = send_log2_hist
